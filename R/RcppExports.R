# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' get_to_from
#'
#' Get one pair of two and from edges and vertices. Main task is to make sure
#' that bi-directed edges ("intermediate_double") correctly return the
#' **different** values of from and to vertices and edges.
#'
#' @noRd
NULL

#' same_hwy_type
#'
#' Determine whether two edges represent the same weight category (type of
#' highway for street networks, for example). Categories are not retained in 
#' converted graphs, but can be discerned by comparing ratios of weighted to
#' non-weighted distances.
#' @noRd
NULL

#' rcpp_contract_graph
#'
#' Removes nodes and edges from a graph that are not needed for routing
#'
#' @param graph graph to be processed
#'
#' @return \code{Rcpp::List} containing one \code{data.frame} with the
#' contracted graph, one \code{data.frame} with the original graph and one
#' \code{data.frame} containing information about the relating edge ids of the
#' original and contracted graph.
#'
#' @noRd
rcpp_contract_graph <- function(graph, vertlist_in) {
    .Call(`_dodgr_rcpp_contract_graph`, graph, vertlist_in)
}

#' rcpp_merge_flows
#'
#' Merge flows in directed graph to form aggregate undirected flows, and return
#' a corresponding undirected graph useful for visualisation.
#'
#' @param graph The result of a call to \code{dodgr_flows}
#' @return A single vector of aggregate flows with non-zero values only for
#' those edges to be retained in the directed graph.
#'
#' @noRd
rcpp_merge_flows <- function(graph) {
    .Call(`_dodgr_rcpp_merge_flows`, graph)
}

#' graph_has_components
#'
#' Does a graph have a vector of connected component IDs? Only used in
#' \code{sample_one_vertex}
#' @noRd
NULL

#' graph_from_df
#'
#' Convert a standard graph data.frame into an object of class graph. Graphs
#' are standardised with the function \code{dodgr_convert_graph()$graph}, and contain
#' only the four columns [from, to, d, w]
#'
#' @noRd
NULL

#' identify_graph_components
#'
#' Identify initial graph components for each **vertex**
#' Identification for edges is subsequently perrformed with 
#' \code{rcpp_get_component_vector}.
#'
#' @param v unordered_map <vertex_id_t, vertex_t>
#' @param com component map from each vertex to component numbers
#' @noRd
NULL

#' rcpp_get_component_vector
#'
#' Get component numbers for each edge of graph
#'
#' @param graph graph to be processed; stripped down and standardised to five
#' columns
#'
#' @return Two vectors: one of edge IDs and one of corresponding component
#' numbers
#' @noRd
rcpp_get_component_vector <- function(graph) {
    .Call(`_dodgr_rcpp_get_component_vector`, graph)
}

#' sample_one_edge_no_comps
#'
#' Sample one edge for graph that has no pre-calculated components. Only used
#' in \code{sample_one_vertex}
#'
#' @param edge_map edge_map
#' @return std::vector of 2 elements: [0] with value of largest connected 
#' component; [1] with random index to one edge that is part of that component.
#' @noRd
NULL

#' sample_one_edge_with_comps
#'
#' Sample one edge for graph that has pre-calculated components. Only used in
#' \code{sample_one_vertex}
#'
#' @param edge_map edge_map
#' @return Random index to one edge that is part of the largest connected
#' component.
#' @noRd
NULL

#' rcpp_sample_graph
#'
#' Randomly sample one connected componnent of a graph
#'
#' @param graph graph to be processed
#' @param nverts_to_sample Number of vertices to sample
#' @param quiet If TRUE, display progress
#'
#' @return Smaller sub-set of \code{graph}
#'
#' @noRd
rcpp_sample_graph <- function(graph, nverts_to_sample) {
    .Call(`_dodgr_rcpp_sample_graph`, graph, nverts_to_sample)
}

#' rcpp_get_sp_dists
#'
#' @noRd
rcpp_get_sp_dists <- function(graph, vert_map_in, fromi, toi, heap_type) {
    .Call(`_dodgr_rcpp_get_sp_dists`, graph, vert_map_in, fromi, toi, heap_type)
}

#' rcpp_get_paths
#'
#' @param graph The data.frame holding the graph edges
#' @param vert_map_in map from <std::string> vertex ID to (0-indexed) integer
#' index of vertices
#' @param fromi Index into vert_map_in of vertex numbers
#' @param toi Index into vert_map_in of vertex numbers
#'
#' @note The graph is constructed with 0-indexed vertex numbers contained in
#' code{vert_map_in}. Both \code{fromi} and \code{toi} already map directly
#' onto these. The graph has to be constructed by first constructing a
#' \code{std::map} object (\code{vertmap}) for \code{vert_map_in}, then
#' translating all \code{graph["from"/"to"]} values into these indices. This
#' construction is done in \code{inst_graph}.
#'
#' @noRd
rcpp_get_paths <- function(graph, vert_map_in, fromi, toi, heap_type) {
    .Call(`_dodgr_rcpp_get_paths`, graph, vert_map_in, fromi, toi, heap_type)
}

#' rcpp_aggregate_flows
#'
#' @param graph The data.frame holding the graph edges
#' @param vert_map_in map from <std::string> vertex ID to (0-indexed) integer
#' index of vertices
#' @param fromi Index into vert_map_in of vertex numbers
#' @param toi Index into vert_map_in of vertex numbers
#'
#' @note The flow data to be used for aggregation is a matrix mapping flows
#' betwen each pair of from and to points.
#'
#' @noRd
rcpp_aggregate_flows <- function(graph, vert_map_in, fromi, toi, flows, heap_type) {
    .Call(`_dodgr_rcpp_aggregate_flows`, graph, vert_map_in, fromi, toi, flows, heap_type)
}

#' rcpp_sf_as_network
#'
#' Return OSM data in Simple Features format
#'
#' @param sf_lines An sf collection of LINESTRING objects
#' @param pr Rcpp::DataFrame containing the weighting profile
#'
#' @return Rcpp::List objects of OSM data
#'
#' @noRd
rcpp_sf_as_network <- function(sf_lines, pr) {
    .Call(`_dodgr_rcpp_sf_as_network`, sf_lines, pr)
}

#' rcpp_points_index
#'
#' Get index of nearest vertices to list of points
#'
#' @param graph Rcpp::DataFrame containing the graph
#' @param pts Rcpp::DataFrame containing the routing points
#'
#' @return Rcpp::NumericVector index into graph of nearest points
#'
#' @noRd
rcpp_points_index <- function(xy, pts) {
    .Call(`_dodgr_rcpp_points_index`, xy, pts)
}

